"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tsCodegen = void 0;
const language_core_1 = require("@volar/language-core");
const computeds_1 = require("computeds");
const script_1 = require("../generators/script");
const template_1 = require("../generators/template");
const utils_1 = require("../generators/utils");
const scriptRanges_1 = require("../parsers/scriptRanges");
const scriptSetupRanges_1 = require("../parsers/scriptSetupRanges");
exports.tsCodegen = new WeakMap();
const plugin = (ctx) => {
    return {
        version: 2,
        requiredCompilerOptions: [
            'noPropertyAccessFromIndexSignature',
            'exactOptionalPropertyTypes',
        ],
        getEmbeddedCodes(fileName, sfc) {
            const tsx = useTsx(fileName, sfc);
            const files = [];
            if (['js', 'ts', 'jsx', 'tsx'].includes(tsx.lang())) {
                files.push({ id: 'script_' + tsx.lang(), lang: tsx.lang() });
            }
            if (sfc.template) {
                files.push({ id: 'template_format', lang: 'ts' });
                files.push({ id: 'template_style', lang: 'css' });
            }
            return files;
        },
        resolveEmbeddedCode(fileName, sfc, embeddedFile) {
            const _tsx = useTsx(fileName, sfc);
            if (embeddedFile.id.startsWith('script_')) {
                const tsx = _tsx.generatedScript();
                if (tsx) {
                    const [content, contentStacks] = ctx.codegenStack ? (0, language_core_1.track)([...tsx.codes], [...tsx.codeStacks]) : [[...tsx.codes], [...tsx.codeStacks]];
                    content.forEach(code => {
                        if (typeof code !== 'string') {
                            code[3].structure = false;
                            code[3].format = false;
                        }
                    });
                    embeddedFile.content = content;
                    embeddedFile.contentStacks = contentStacks;
                    embeddedFile.linkedCodeMappings = [...tsx.linkedCodeMappings];
                }
            }
            else if (embeddedFile.id === 'template_format') {
                embeddedFile.parentCodeId = 'template';
                const template = _tsx.generatedTemplate();
                if (template) {
                    const [content, contentStacks] = ctx.codegenStack
                        ? (0, language_core_1.track)([...template.formatCodes], template.formatCodeStacks.map(stack => ({ stack, length: 1 })))
                        : [[...template.formatCodes], template.formatCodeStacks.map(stack => ({ stack, length: 1 }))];
                    embeddedFile.content = content;
                    embeddedFile.contentStacks = contentStacks;
                }
                for (const style of sfc.styles) {
                    embeddedFile.content.push('\n\n');
                    for (const cssVar of style.cssVars) {
                        embeddedFile.content.push('(');
                        embeddedFile.content.push([
                            cssVar.text,
                            style.name,
                            cssVar.offset,
                            (0, utils_1.enableAllFeatures)({}),
                        ]);
                        embeddedFile.content.push(');\n');
                    }
                }
            }
            else if (embeddedFile.id === 'template_style') {
                embeddedFile.parentCodeId = 'template';
                const template = _tsx.generatedTemplate();
                if (template) {
                    const [content, contentStacks] = ctx.codegenStack
                        ? (0, language_core_1.track)([...template.cssCodes], template.cssCodeStacks.map(stack => ({ stack, length: 1 })))
                        : [[...template.cssCodes], template.cssCodeStacks.map(stack => ({ stack, length: 1 }))];
                    embeddedFile.content = content;
                    embeddedFile.contentStacks = contentStacks;
                }
            }
        },
    };
    function useTsx(fileName, sfc) {
        if (!exports.tsCodegen.has(sfc)) {
            exports.tsCodegen.set(sfc, createTsx(fileName, sfc, ctx));
        }
        return exports.tsCodegen.get(sfc);
    }
};
exports.default = plugin;
function createTsx(fileName, _sfc, ctx) {
    const ts = ctx.modules.typescript;
    const lang = (0, computeds_1.computed)(() => {
        return !_sfc.script && !_sfc.scriptSetup ? 'ts'
            : _sfc.scriptSetup && _sfc.scriptSetup.lang !== 'js' ? _sfc.scriptSetup.lang
                : _sfc.script && _sfc.script.lang !== 'js' ? _sfc.script.lang
                    : 'js';
    });
    const scriptRanges = (0, computeds_1.computed)(() => _sfc.script
        ? (0, scriptRanges_1.parseScriptRanges)(ts, _sfc.script.ast, !!_sfc.scriptSetup, false)
        : undefined);
    const scriptSetupRanges = (0, computeds_1.computed)(() => _sfc.scriptSetup
        ? (0, scriptSetupRanges_1.parseScriptSetupRanges)(ts, _sfc.scriptSetup.ast, ctx.vueCompilerOptions)
        : undefined);
    const shouldGenerateScopedClasses = (0, computeds_1.computed)(() => {
        const option = ctx.vueCompilerOptions.experimentalResolveStyleCssClasses;
        return _sfc.styles.some(s => {
            return option === 'always' || (option === 'scoped' && s.scoped);
        });
    });
    const stylesScopedClasses = (0, computeds_1.computedSet)(() => {
        const classes = new Set();
        if (!shouldGenerateScopedClasses()) {
            return classes;
        }
        for (const style of _sfc.styles) {
            const option = ctx.vueCompilerOptions.experimentalResolveStyleCssClasses;
            if (option === 'always' || (option === 'scoped' && style.scoped)) {
                for (const className of style.classNames) {
                    classes.add(className.text.substring(1));
                }
            }
        }
        return classes;
    });
    const generatedTemplate = (0, computeds_1.computed)(() => {
        if (!_sfc.template)
            return;
        const tsCodes = [];
        const tsFormatCodes = [];
        const inlineCssCodes = [];
        const tsCodegenStacks = [];
        const tsFormatCodegenStacks = [];
        const inlineCssCodegenStacks = [];
        const codegen = (0, template_1.generate)(ts, ctx.compilerOptions, ctx.vueCompilerOptions, _sfc.template, shouldGenerateScopedClasses(), stylesScopedClasses(), hasScriptSetupSlots(), slotsAssignName(), propsAssignName(), ctx.codegenStack);
        let current = codegen.next();
        while (!current.done) {
            const [type, code, stack] = current.value;
            if (type === 'ts') {
                tsCodes.push(code);
            }
            else if (type === 'tsFormat') {
                tsFormatCodes.push(code);
            }
            else if (type === 'inlineCss') {
                inlineCssCodes.push(code);
            }
            if (ctx.codegenStack) {
                if (type === 'ts') {
                    tsCodegenStacks.push(stack);
                }
                else if (type === 'tsFormat') {
                    tsFormatCodegenStacks.push(stack);
                }
                else if (type === 'inlineCss') {
                    inlineCssCodegenStacks.push(stack);
                }
            }
            current = codegen.next();
        }
        return {
            ...current.value,
            codes: tsCodes,
            codeStacks: tsCodegenStacks,
            formatCodes: tsFormatCodes,
            formatCodeStacks: tsFormatCodegenStacks,
            cssCodes: inlineCssCodes,
            cssCodeStacks: inlineCssCodegenStacks,
        };
    });
    const hasScriptSetupSlots = (0, computeds_1.computed)(() => !!scriptSetupRanges()?.slots.define);
    const slotsAssignName = (0, computeds_1.computed)(() => scriptSetupRanges()?.slots.name);
    const propsAssignName = (0, computeds_1.computed)(() => scriptSetupRanges()?.props.name);
    const generatedScript = (0, computeds_1.computed)(() => {
        const codes = [];
        const codeStacks = [];
        const linkedCodeMappings = [];
        const _template = generatedTemplate();
        let generatedLength = 0;
        for (const [code, stack] of (0, script_1.generate)(ts, fileName, _sfc.script, _sfc.scriptSetup, _sfc.styles, lang(), scriptRanges(), scriptSetupRanges(), _template ? {
            tsCodes: _template.codes,
            tsCodegenStacks: _template.codeStacks,
            accessedGlobalVariables: _template.accessedGlobalVariables,
            hasSlot: _template.hasSlot,
            tagNames: new Set(_template.tagOffsetsMap.keys()),
        } : undefined, ctx.compilerOptions, ctx.vueCompilerOptions, ctx.globalTypesHolder, () => generatedLength, linkedCodeMappings, ctx.codegenStack)) {
            codes.push(code);
            if (ctx.codegenStack) {
                codeStacks.push({ stack, length: 1 });
            }
            generatedLength += typeof code === 'string'
                ? code.length
                : code[0].length;
        }
        ;
        return {
            codes,
            codeStacks,
            linkedCodeMappings,
        };
    });
    return {
        scriptRanges,
        scriptSetupRanges,
        lang,
        generatedScript,
        generatedTemplate,
    };
}
//# sourceMappingURL=vue-tsx.js.map