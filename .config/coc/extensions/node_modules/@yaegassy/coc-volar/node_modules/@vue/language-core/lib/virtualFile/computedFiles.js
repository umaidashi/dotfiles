"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computedFiles = void 0;
const language_core_1 = require("@volar/language-core");
const computeds_1 = require("computeds");
const embeddedFile_1 = require("./embeddedFile");
function computedFiles(plugins, fileName, sfc, codegenStack) {
    const nameToBlock = (0, computeds_1.computed)(() => {
        const blocks = {};
        if (sfc.template) {
            blocks[sfc.template.name] = sfc.template;
        }
        if (sfc.script) {
            blocks[sfc.script.name] = sfc.script;
        }
        if (sfc.scriptSetup) {
            blocks[sfc.scriptSetup.name] = sfc.scriptSetup;
        }
        for (const block of sfc.styles) {
            blocks[block.name] = block;
        }
        for (const block of sfc.customBlocks) {
            blocks[block.name] = block;
        }
        return blocks;
    });
    const pluginsResult = plugins.map(plugin => computedPluginFiles(plugins, plugin, fileName, sfc, nameToBlock, codegenStack));
    const flatResult = (0, computeds_1.computed)(() => pluginsResult.map(r => r()).flat());
    const structuredResult = (0, computeds_1.computed)(() => {
        const embeddedCodes = [];
        let remain = [...flatResult()];
        while (remain.length) {
            const beforeLength = remain.length;
            consumeRemain();
            if (beforeLength === remain.length) {
                break;
            }
        }
        for (const { file, snapshot, mappings, codegenStacks } of remain) {
            embeddedCodes.push({
                id: file.id,
                languageId: (0, language_core_1.resolveCommonLanguageId)(`/dummy.${file.lang}`),
                linkedCodeMappings: file.linkedCodeMappings,
                snapshot,
                mappings,
                codegenStacks,
                embeddedCodes: [],
            });
            console.error('Unable to resolve embedded: ' + file.parentCodeId + ' -> ' + file.id);
        }
        return embeddedCodes;
        function consumeRemain() {
            for (let i = remain.length - 1; i >= 0; i--) {
                const { file, snapshot, mappings, codegenStacks } = remain[i];
                if (!file.parentCodeId) {
                    embeddedCodes.push({
                        id: file.id,
                        languageId: (0, language_core_1.resolveCommonLanguageId)(`/dummy.${file.lang}`),
                        linkedCodeMappings: file.linkedCodeMappings,
                        snapshot,
                        mappings,
                        codegenStacks,
                        embeddedCodes: [],
                    });
                    remain.splice(i, 1);
                }
                else {
                    const parent = findParentStructure(file.parentCodeId, embeddedCodes);
                    if (parent) {
                        parent.embeddedCodes ??= [];
                        parent.embeddedCodes.push({
                            id: file.id,
                            languageId: (0, language_core_1.resolveCommonLanguageId)(`/dummy.${file.lang}`),
                            linkedCodeMappings: file.linkedCodeMappings,
                            snapshot,
                            mappings,
                            codegenStacks,
                            embeddedCodes: [],
                        });
                        remain.splice(i, 1);
                    }
                }
            }
        }
        function findParentStructure(id, current) {
            for (const child of current) {
                if (child.id === id) {
                    return child;
                }
                let parent = findParentStructure(id, child.embeddedCodes ?? []);
                if (parent) {
                    return parent;
                }
            }
        }
    });
    return structuredResult;
}
exports.computedFiles = computedFiles;
function computedPluginFiles(plugins, plugin, fileName, sfc, nameToBlock, codegenStack) {
    const embeddedFiles = {};
    const files = (0, computeds_1.computed)(() => {
        try {
            if (!plugin.getEmbeddedCodes) {
                return Object.values(embeddedFiles);
            }
            const fileInfos = plugin.getEmbeddedCodes(fileName, sfc);
            for (const oldId of Object.keys(embeddedFiles)) {
                if (!fileInfos.some(file => file.id === oldId)) {
                    delete embeddedFiles[oldId];
                }
            }
            for (const fileInfo of fileInfos) {
                if (!embeddedFiles[fileInfo.id]) {
                    embeddedFiles[fileInfo.id] = (0, computeds_1.computed)(() => {
                        const [content, stacks] = codegenStack ? (0, language_core_1.track)([]) : [[], []];
                        const file = new embeddedFile_1.VueEmbeddedCode(fileInfo.id, fileInfo.lang, content, stacks);
                        for (const plugin of plugins) {
                            if (!plugin.resolveEmbeddedCode) {
                                continue;
                            }
                            try {
                                plugin.resolveEmbeddedCode(fileName, sfc, file);
                            }
                            catch (e) {
                                console.error(e);
                            }
                        }
                        const newText = (0, language_core_1.toString)(file.content);
                        const changeRanges = new Map();
                        const snapshot = {
                            getText: (start, end) => newText.slice(start, end),
                            getLength: () => newText.length,
                            getChangeRange(oldSnapshot) {
                                if (!changeRanges.has(oldSnapshot)) {
                                    changeRanges.set(oldSnapshot, undefined);
                                    const oldText = oldSnapshot.getText(0, oldSnapshot.getLength());
                                    const changeRange = fullDiffTextChangeRange(oldText, newText);
                                    if (changeRange) {
                                        changeRanges.set(oldSnapshot, changeRange);
                                    }
                                }
                                return changeRanges.get(oldSnapshot);
                            },
                        };
                        return {
                            file,
                            snapshot,
                        };
                    });
                }
            }
        }
        catch (e) {
            console.error(e);
        }
        return Object.values(embeddedFiles);
    });
    return (0, computeds_1.computed)(() => {
        return files().map(_file => {
            const { file, snapshot } = _file();
            const mappings = (0, language_core_1.buildMappings)(file.content);
            let lastValidMapping;
            for (const mapping of mappings) {
                if (mapping.source !== undefined) {
                    const block = nameToBlock()[mapping.source];
                    if (block) {
                        mapping.sourceOffsets = mapping.sourceOffsets.map(offset => offset + block.startTagEnd);
                    }
                    else {
                        // ignore
                    }
                    mapping.source = undefined;
                }
                if (mapping.data.__combineLastMapping) {
                    lastValidMapping.sourceOffsets.push(...mapping.sourceOffsets);
                    lastValidMapping.generatedOffsets.push(...mapping.generatedOffsets);
                    lastValidMapping.lengths.push(...mapping.lengths);
                    continue;
                }
                else {
                    lastValidMapping = mapping;
                }
            }
            return {
                file,
                snapshot,
                mappings: mappings.filter(mapping => !mapping.data.__combineLastMapping),
                codegenStacks: (0, language_core_1.buildStacks)(file.content, file.contentStacks),
            };
        });
    });
}
function fullDiffTextChangeRange(oldText, newText) {
    for (let start = 0; start < oldText.length && start < newText.length; start++) {
        if (oldText[start] !== newText[start]) {
            let end = oldText.length;
            for (let i = 0; i < oldText.length - start && i < newText.length - start; i++) {
                if (oldText[oldText.length - i - 1] !== newText[newText.length - i - 1]) {
                    break;
                }
                end--;
            }
            let length = end - start;
            let newLength = length + (newText.length - oldText.length);
            if (newLength < 0) {
                length -= newLength;
                newLength = 0;
            }
            return {
                span: { start, length },
                newLength,
            };
        }
    }
}
//# sourceMappingURL=computedFiles.js.map