"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.server = exports.connection = void 0;
const node_1 = require("@volar/language-server/node");
const language_core_1 = require("@vue/language-core");
const language_service_1 = require("@vue/language-service");
const protocol_1 = require("./lib/protocol");
const tsPluginClient = require("@vue/typescript-plugin/lib/client");
const protocol_2 = require("./lib/protocol");
exports.connection = (0, node_1.createConnection)();
exports.server = (0, node_1.createServer)(exports.connection);
const envToVueOptions = new WeakMap();
let tsdk;
exports.connection.listen();
exports.connection.onInitialize(async (params) => {
    const options = params.initializationOptions;
    tsdk = (0, node_1.loadTsdkByPath)(options.typescript.tsdk, params.locale);
    const vueFileExtensions = ['vue'];
    if (options.vue?.additionalExtensions) {
        for (const additionalExtension of options.vue.additionalExtensions) {
            vueFileExtensions.push(additionalExtension);
        }
    }
    const result = await exports.server.initialize(params, (0, node_1.createSimpleProjectProviderFactory)(), {
        watchFileExtensions: ['js', 'cjs', 'mjs', 'ts', 'cts', 'mts', 'jsx', 'tsx', 'json', ...vueFileExtensions],
        getServicePlugins() {
            return (0, language_service_1.createVueServicePlugins)(tsdk.typescript, env => envToVueOptions.get(env), tsPluginClient);
        },
        async getLanguagePlugins(serviceEnv, projectContext) {
            const [commandLine, vueOptions] = await parseCommandLine();
            const resolvedVueOptions = (0, language_core_1.resolveVueCompilerOptions)(vueOptions);
            const vueLanguagePlugin = (0, language_core_1.createVueLanguagePlugin)(tsdk.typescript, serviceEnv.typescript.uriToFileName, fileName => {
                if (projectContext.typescript?.sys.useCaseSensitiveFileNames ?? false) {
                    return projectContext.typescript?.host.getScriptFileNames().includes(fileName) ?? false;
                }
                else {
                    const lowerFileName = fileName.toLowerCase();
                    for (const rootFile of projectContext.typescript?.host.getScriptFileNames() ?? []) {
                        if (rootFile.toLowerCase() === lowerFileName) {
                            return true;
                        }
                    }
                    return false;
                }
            }, commandLine?.options ?? {}, resolvedVueOptions, options.codegenStack);
            envToVueOptions.set(serviceEnv, resolvedVueOptions);
            return [vueLanguagePlugin];
            async function parseCommandLine() {
                let commandLine;
                let vueOptions = {};
                if (projectContext.typescript) {
                    const { sys } = projectContext.typescript;
                    let sysVersion;
                    let newSysVersion = await sys.sync();
                    while (sysVersion !== newSysVersion) {
                        sysVersion = newSysVersion;
                        if (projectContext.typescript.configFileName) {
                            commandLine = (0, language_core_1.createParsedCommandLine)(tsdk.typescript, sys, projectContext.typescript.configFileName);
                        }
                        newSysVersion = await sys.sync();
                    }
                }
                if (commandLine) {
                    vueOptions = commandLine.vueOptions;
                }
                vueOptions.extensions = [
                    ...vueOptions.extensions ?? ['.vue'],
                    ...vueFileExtensions.map(ext => '.' + ext),
                ];
                vueOptions.extensions = [...new Set(vueOptions.extensions)];
                return [commandLine, vueOptions];
            }
        },
    });
    // handle by tsserver + @vue/typescript-plugin
    result.capabilities.semanticTokensProvider = undefined;
    return result;
});
exports.connection.onInitialized(() => {
    exports.server.initialized();
});
exports.connection.onShutdown(() => {
    exports.server.shutdown();
});
exports.connection.onRequest(protocol_1.ParseSFCRequest.type, params => {
    return (0, language_core_1.parse)(params);
});
exports.connection.onRequest(protocol_1.DetectNameCasingRequest.type, async (params) => {
    const languageService = await getService(params.textDocument.uri);
    if (languageService) {
        return await (0, language_service_1.detect)(languageService.context, params.textDocument.uri, tsPluginClient);
    }
});
exports.connection.onRequest(protocol_1.GetConvertTagCasingEditsRequest.type, async (params) => {
    const languageService = await getService(params.textDocument.uri);
    if (languageService) {
        return await (0, language_service_1.convertTagName)(languageService.context, params.textDocument.uri, params.casing, tsPluginClient);
    }
});
exports.connection.onRequest(protocol_1.GetConvertAttrCasingEditsRequest.type, async (params) => {
    const languageService = await getService(params.textDocument.uri);
    if (languageService) {
        return await (0, language_service_1.convertAttrName)(languageService.context, params.textDocument.uri, params.casing, tsPluginClient);
    }
});
exports.connection.onRequest(protocol_2.GetConnectedNamedPipeServerRequest.type, async (fileName) => {
    const server = await tsPluginClient.searchNamedPipeServerForFile(fileName);
    if (server) {
        return server;
    }
});
async function getService(uri) {
    return (await exports.server.projects.getProject(uri)).getLanguageService();
}
//# sourceMappingURL=node.js.map